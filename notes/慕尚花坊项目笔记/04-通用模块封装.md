## 通用模块封装



### 01. 为什么进行模块封装



在进行项目开发的时候，我们经常的会频繁的使用到一些 API，

例如：`wx.showToast()` 、`wx.showModal()`等消息提示 `API` ，这些 API 的使用方法如下:

```js
wx.showToast({
  title: '消息提示框', // 提示的内容
  icon: 'success',   // 提示图标
  duration: 2000,	 // 提示的延迟时间
  mask: true		 // 是否显示透明蒙层，防止触摸穿透
})

wx.showModal({
  title: '提示', // 提示的标题
  content: '您确定执行该操作吗？', // 提示的内容
  confirmColor: '#f3514f', // 确定按钮的样式
  // 接口调用结束的回调函数（调用成功、失败都会执行）
  complete({ confirm, cancel }) {
    if (confirm) {
      console.log('用户点击了确定')
      return
    }

    if (cancel) {
      console.log('用户点击了取消')
    }
  }
})
```



如果每次使用的时候，都直接调用这些 `API`，会导致代码很冗余，为了减少了代码冗余，我们需要将这些 `API` 封装成公共方法，封装后的使用方式如下：

```js
// wx.showToast() 封装后的调用方式
toast()
toast({ title: '数据加载失败....', mask: true })

// wx.showModal() 封装后的调用方式
const res = await modal({
  title: '提示',
  content: '鉴权失败，请重新登录 ？'
})

// 用户点击了确定
if (res) { ... } else { ... }
```



可以看到封装后方法，极大简化 API 的调用，

同时，我们在后续还会进行网络通用模块的封装，如果直接进行封装难度比较大，

进行通过模块的封装，也是为后续 [网络请求封装] 做铺垫。









### 02. 消息提示模块封装



**基本使用：**



`wx.showToast()` 消息提示框是在项目中频繁使用的一个小程序 `API`，常用来给用户进行消息提示反馈。使用方式如下：

```js
wx.showToast({
  title: '消息提示框', // 提示的内容
  icon: 'success',   // 提示的图标，success(成功)、error(失败)、loading(加载)、none(不显示图标)
  duration: 2000,	 // 提示的延迟时间
  mask: true		 // 是否显示透明蒙层，防止触摸穿透
})
```



**封装思路：**

1. 创建一个 `toast` 方法对 `wx.showToast()` 方法进行封装

2. 调用该方法时，传递对象作为参数

   - 如果没有传递任何参数，设置一个空对象 `{}` 作为默认参数

   - 从对象中包含 `title`、`icon`、`duration`、`mask` 参数，并给参数设置默认值

3. 在需要显示弹出框的时候调用 `toast` 方法，并传入相关的参数，有两种参数方式：

   - 不传递参数，使用默认参值
   - 传入部分参数，覆盖默认的参数



**调用方式：**

新封装的模块，我们希望有两种调用的方式：



1. 模块化的方式导入使用

   ```js
   import { toast } from './extendApi'
   
   toast()
   toast({ title: '数据加载失败....', mask: true })
   ```

   

2. 将封装的模块挂载到 `wx` 全局对象身上

   当你将封装的模块（比如 toast）挂载到 wx 全局对象上后，理论上来说在小程序的生命周期内，一旦这个操作被执行一次，后续在同一个小程序的其他任何地方都可以直接通过 wx.toast 来调用这个模块。
   
   ```js
   wx.toast()
   wx.toast({ title: '数据加载失败....', mask: true })
   ```
   
   



**实现步骤：**

1. 在 `utils` 目录下新建 `extendApi.js` 文件
2. 对 `wx.showToast()` 方法进行封装



**落地代码：**



`➡️ utils/extendApi.js`

```js
/**
 * @description 封装消息提示组件
 * @param {*} title 提示的内容
 * @param {*} icon 图标
 * @param {*} duration 提示的延迟时间
 * @param {*} mask 是否显示透明蒙层，防止触摸穿透
 */
const toast = ({ title = '数据加载中', icon = 'none', mask = true, duration = 3000 } = {}) => {
  wx.showToast({
    title,
    icon,
    mask,
    duration
  })
}

// 在 wx 全局对象上封装 toast 方法
// 调用 API 方式：
// 1. 在入口文件 app.js 导入封装的模块  import './utils/extendApi'
// 2. 调用封装的方法：wx.toast('')
wx.toast = toast

// 模块化的方式使用
// 调用 API 方式：
// 1. 导入该文件：import { toast } from '../utils/extendApi'
// 2. 调用封装的方法：toast('')
export { toast }

```



`➡️ app.js`

```js
import { toast } from './utils/extendApi'

App({
  onLaunch() {

    // 第一种调用方式：不传入任何参数
    toast()

    // 第二种调用方式：传入部分参数
    toast({ title: '数据加载失败....', mask: true })
    
    // 第三种调用方式：传入全部的参数
    toast({ title: '数据加载失败....', mask: true })
    
  }
})
```









###  03. **模态对话框封装**



**基本使用：**



`wx.showModal()` 模态对话框也是在项目中频繁使用的一个小程序 `API`，通常用于向用户询问是否执行一些操作，例如：询问用户是否真的需要退出、是否确认删除等等 

```js
wx.showModal({
  title: '提示', // 提示的标题
  content: '您确定执行该操作吗？', // 提示的内容
  confirmColor: '#f3514f',
  // 接口调用结束的回调函数（调用成功、失败都会执行）
  complete({ confirm, cancel }) {
    confirm && console.log('点击了确定')
    cancel && console.log('点击了取消')
  }
})
```

> 在 JavaScript 中，`&&`运算符的特点是当左侧表达式的值为真时，才会继续对右侧表达式进行求值并返回其值；如果左侧表达式的值为假，则直接返回左侧表达式的值，不再对右侧表达式进行求值。
>
> 当`confirm`为真值时，整个表达式继续执行右侧的`console.log('点击了确定')`，而这个表达式本身是一个有副作用的语句（输出日志），并且会返回一个值（在严格模式下返回`undefined`，非严格模式下根据浏览器实现可能会返回不同的值）。但是这里重点不是关注右侧表达式返回的值，而是利用`&&`的特性来有条件地执行这个输出日志的操作。
>
> 所以虽然右侧不是传统的逻辑判断式子，但在这种使用场景下，是利用`&&`运算符的短路特性来实现有条件地执行特定的操作。



**封装思路：**



1. 对 `wx.showModal()` 方法进行封装， 封装后的新方法叫 `modal` 
2. 调用该方法时，传递对象作为参数，对象的参数同 `wx.showModal()` 参数一致
3. 封装的 `modal` 方法的内部通过 `Promise` 返回用户执行的操作(确定和取消，都通过 resolve 返回)
4. 在需要显示模态对话框的时候调用 `modal` 方法，并传入相关的参数，有三种调用方式：
   - 不传递参数，使用默认参数
   - 传递参数，覆盖默认的参数



**调用方式：**

新封装的本地存储模块，我们依然希望有两种调用的方式：

1. 模块化的方式导入使用
2. 将封装的模块挂载到 `wx` 全局对象身上



**实现步骤：**

1. 在 `extendApi.js` 文件中新建 `modal` 方法，方法内部
2. `modal` 方法，方法内部用来处理封装的逻辑



**落地代码：**



`➡️ utils/extendApi.js`

```js
// coding...

/**
 * @description 封装 wx.showModal  方法
 * @param {*} options 同 wx.showModal 配置项
 */
export const modal = (options = {}) => {
  // 使用 Promise 处理 wx.showModal 的返回结果
  return new Promise((resolve) => {

    // 默认的参数
    const defaultOpt = {
      title: '提示',
      content: '您确定执行该操作吗?',
      confirmColor: '#f3514f',
    }

    // 将传入的参数和默认的参数进行合并
    const opts = Object.assign({}, defaultOpt, options)

    wx.showModal({
      // 将合并的参数赋值传递给 showModal 方法
      ...opts,
      complete({ confirm, cancel }) {
        // 如果用户点击了确定，通过 resolve 抛出 true
        // 如果用户点击了取消，通过 resolve 抛出 false
        confirm && resolve(true)
        cancel && resolve(false)
      }
    })
  })
}

// 在 wx 全局对象上封装 myToast 方法
// 调用 API 方式：
// 1. 在入口文件 app.js 导入封装的模块  import './utils/extendApi'
// 2. 调用封装的方法：wx.toast('')
wx.toast = toast
+ wx.modal = modal

// 模块化的方式使用
// 调用 API 方式：
// 1. 导入该文件：import { toast } from '../utils/extendApi'
// 2. 调用封装的方法：toast('')
+ export { toast, modal }

```

> 1. 关于 `options = {}`：
>
>    - 这是函数参数的默认值设定。当调用这个函数时，如果没有传入任何参数，`options` 就会是一个空对象。这样做的目的是确保即使没有明确传入参数，函数也能正常工作，不会因为缺少参数而出现错误。
>    - 它为函数的使用提供了一种便捷性，调用者可以选择传入自己的配置参数，也可以直接调用函数而不传入任何参数，此时就会使用默认的配置。
>
> 2. 关于创建默认参数 `defaultOpt` 并与传入参数合并：
>
>    - `defaultOpt` 是为了定义一组合理的默认配置，这样可以确保在没有传入特定参数时，`wx.showModal` 也能以一种可预期的方式展示。例如，默认的标题是 “提示”，内容是 “您确定执行该操作吗？”，确定按钮颜色是特定的颜色码。
>    - `const opts = Object.assign({}, defaultOpt, options)` 这行代码的作用是将默认参数和用户传入的参数进行合并。首先创建一个空对象 `{}`，然后将 `defaultOpt` 的属性复制到这个空对象上，接着如果有用户传入的参数 `options`，会覆盖掉默认参数中相同属性的值。这样做的好处是既保证了有默认值可用，又允许用户根据自己的需求进行定制。
>
>    
>
> 3. `resolve`的作用：
>
>    - `resolve`函数的作用是通知 Promise 对象所代表的异步操作已经成功完成，并将结果值传递给后续的`.then()`方法进行处理。
>
>    - 在这个封装的`modal`函数中，`resolve`被用来根据用户在模态对话框中的操作（点击确定或取消），将相应的结果（`true`表示确定，`false`表示取消）传递给调用这个函数的地方。
>
>    - 可以在调用`modal`函数后，使用`.then(result => {...})`来根据用户的选择执行不同的操作，<u>这里`then`函数形参里的 `result` 是前面调用`resolve` 传递的值</u>，即ture or false。函数如果用户点击确定，可以执行一些特定的业务逻辑，如果用户点击取消，可以执行其他的逻辑。
>
>      
>
> 4. 展开运算符`...`：
>
>    - 数组展开
>
>      可以将一个数组拆分成它的各个元素。例如：
>
>      ```js
>           const arr1 = [1, 2, 3];
>           const arr2 = [4, 5, 6];
>           const combinedArray = [...arr1,...arr2];
>           console.log(combinedArray); // [1, 2, 3, 4, 5, 6]
>      ```
>
>    - 对象展开
>
>      可以将一个对象的属性复制到另一个对象中。例如：
>
>      ```js
>           const obj1 = { a: 1, b: 2 };
>           const obj2 = { c: 3, d: 4 };
>           const combinedObject = {...obj1,...obj2 };
>           console.log(combinedObject); // { a: 1, b: 2, c: 3, d: 4 }
>      ```
>
>    - 剩余参数
>
>      ```js
>      function sum(...numbers) {
>        let total = 0;
>        for (let num of numbers) {
>          total += num;
>        }
>        return total;
>      }
>                
>      console.log(sum(1, 2, 3)); // 6
>      console.log(sum(4, 5, 6, 7)); // 22
>      ```
>
>      在没有剩余参数的情况下，如果要实现一个求和函数，可能需要分别定义接收两个参数、三个参数等不同版本的函数。而使用剩余参数，只需要一个函数就可以处理任意数量的参数。
>
>      但要注意⚠️:
>
>      - 剩余参数必须放在函数参数列表的最后。如果在剩余参数后面还有其他参数，会导致语法错误。
>
>        例如：`function func(a,...b, c) {... }`是错误的语法。
>
>      - 剩余参数的名称不能与函数内部的其他变量或参数名称冲突。如果发生冲突，可能会导致意外的结果。
>
>        例如：`function func(...args, args) {... }`是错误的语法，因为剩余参数`args`与后面的参数名称冲突。
>
>        
>
> 5. **async/await**
>
>    `async`和`await`是基于`Promise`的语法糖，它们提供了一种更加简洁和直观的方式来处理异步操作。
>
>    - `async`：用于声明一个异步函数。异步函数返回一个 Promise 对象，当异步函数中的代码执行完成或者抛出错误时，这个 Promise 对象会被 resolve 或者 reject。
>    - `await`：用于暂停异步函数的执行，等待一个 Promise 对象的解决。<u>如果 Promise 对象被 resolve，`await`表达式的值就是 resolve 的值（下面例子中就是 '成功结果' ）；如果 Promise 对象被 reject，`await`表达式会抛出一个错误（下面例子中就是 '失败结果' ）。</u>
>
>    ```js
>    async function myAsyncFunction() {
>      try {
>        const result = await new Promise((resolve, reject) => {
>          setTimeout(() => {
>            if (Math.random() > 0.5) {
>              resolve('成功结果');
>            } else {
>              reject('失败结果');
>            }
>          }, 1000);
>        });
>        console.log(result);
>      } catch (error) {
>        console.error(error);
>      }
>    }
>          
>    myAsyncFunction();
>    ```
>
>    `await`只能在`async`函数中使用，它等待的对象通常是一个 Promise 对象。





`➡️ app.js`

```js
import { modal } from './utils/extendApi'

App({
  async onLaunch() {
      
    // 第一种调用方式：不传入任何参数
    // 不使用任何参数，使用默认值
    const res = await modal()
    console.log(res)

    // 第二种调用方式：更改默认配置
    const res = await modal({
      content: '鉴权失败，请重新登录',
      showCancel: false
    })
    console.log(res)
  }
})

```

> 使用`const`声明的变量是一个常量，意味着一旦被赋值，就不能再被重新赋值。
>
> 在这个例子中，`res`被声明为常量后，后续的代码不能对`res`重新赋值，比如不能执行`res = somethingElse`这样的操作。
>
> - 好处：增加代码的安全性和可维护性。如果不希望变量的值被意外修改，使用`const`可以防止这种情况发生。
>
> 使用`let`就可以重新赋值, 这是二者主要区别





### 04. 封装本地存储 API



**思路分析：**



在小程序中，经常需要将一些数据存储到本地，方便多个页面的读取使用，例如：将用户的登录状态、用户的个人信息存储到本地。

小程序提供了同步、异步两类 API 来实现本地存储操作。例如:  `wx.setStorageSync`、`wx.setStorage` 等方法



```js
try {
  wx.setStorageSync(key, value)
} catch (err) {
  console.error(`存储指定 ${key} 数据发生错误:`, err)
}

wx.setStorage({
  key: 'key',
  data: 'data',
  success (res) => {},
  fail (err) => {}
})

```



如果直接使用这些 API，会比较麻烦，通常情况下，我们需要对本地存储的方法进行封装。



**实现步骤：**



1. 在 `utils` 目录下新建 `storage.js` 文件
2. 在该文件中，封装对本地数据进行 存储、获取、删除、清除的方法



**落地代码：**



`➡️ utils/storage.js`

```ts
/**
 * @description 存储数据
 * @param {*} key 本地缓存中指定的 key
 * @param {*} value 需要缓存的数据
 */
export const setStorage = (key, value) => {
  try {
    wx.setStorageSync(key, value)
  } catch (e) {
    console.error(`存储指定 ${key} 数据发生错误:`, e)
  }
}

/**
 * @description 从本地读取对应 key 的数据
 * @param {*} key 
 */
export const getStorage = (key) => {
  try {
    const value = wx.getStorageSync(key)
    if (value) {
      return value
    }
  } catch (e) {
    console.error(`获取指定 ${key} 数据发生错误:`, e)
  }
}

/**
 * @description 从本地移除指定 key 数据
 * @param {*} key 
 */
export const removeStorage = (key) => {
   try {
     wx.removeStorageSync(key)
   } catch (err) {
     console.error(`移除指定 ${key} 数据发生错误:`, e)
   }
}

/**
 * @description 从本地清空全部的数据
 */
export const clearStorage = () => {
  try {
    wx.clearStorageSync()
  } catch (e) {
    console.error("清空本地存储时发生错误:", e);
  }
}

```







### 05. 拓展:封装异步存储API+优化代码



**思路分析：**



1. 使用 Promise 封装异步存储 API

   ```js
   wx.setStorage({
     key: 'key',
     data: 'data',
     success(res) {},
     fail(err) {},
     complete(res) {}
   })
   ```

   

2. 给 toast 以及 modal 方法添加注释



**使用方式：**

```js
// 异步将数据存储到本地
asyncSetStorage(key, data)

// 异步从本地读取指定 key 的数据
asyncGetStorage(key)

// 异步从本地移除指定 key 的数据
asyncRemoveStorage(key)

// 异步从本地移除、清空全部的数据
asyncClearStorage()
```



**落地代码：**



`➡️ utils/storage.js`

```js

/**
 * @description 将数据存储到本地 - 异步方法
 * @param {*} key 本地缓存中指定的 key
 * @param {*} data 需要缓存的数据
 */
export const asyncSetStorage = (key, data) => {
  return new Promise((resolve) => {
    wx.setStorage({
      key,
      data,
      complete(res) {
        resolve(res)
      }
    })
  })
}

/**
 * @description 从本地读取指定 key 的数据 - 异步方法
 * @param {*} key
 */
export const asyncGetStorage = (key) => {
  return new Promise((resolve) => {
    wx.getStorage({
      key,
      complete(res) {
        resolve(res)
      }
    })
  })
}

/**
 * @description 从本地移除指定 key 的数据 - 异步方法
 * @param {*} key
 */
export const asyncRemoveStorage = (key) => {
  return new Promise((resolve) => {
    wx.removeStorage({
      key,
      complete(res) {
        resolve(res)
      }
    })
  })
}

/**
 * @description 从本地移除、清空全部的数据 - 异步方法
 */
export const asyncClearStorage = () => {
  return new Promise((resolve) => {
    wx.clearStorage({
      complete(res) {
        resolve(res)
      }
    })
  })
}

```

> 注意⚠️:
>
> `wx.setStorage`方法接受的参数对象中，用于存储数据的属性名是固定为`data`。
>
> 当你直接使用`value`时，小程序并不知道这个值应该存储在哪里，所以最终存储的结果是`undefined`。而当你明确写成`data: storage`时，就告诉了小程序要将`storage`这个值存储在名为`data`的属性下，这样小程序就能正确地识别并存储数据了。



`➡️ utils/extendApi.js`

```js
// coding...

/**
 * @description 消息提示框
 * @param { Object } options 参数和 wx.showToast 参数保持一致
 */
const toast = ({ title = '数据加载中...', icon = 'none', duration = 2000, mask = true } = {}) => {
  // coding...
}

/**
 * @description 模态对话框
 * @param { Object } options 参数和 wx.showModal 参数保持一致
 */
const modal = (options = {}) => {
  // coding...
}

// coding...

```



